<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>MessageSQLServerDAOTest.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">com.uncooleben.dao (Nov 8, 2019 11:51:39 PM)</a> &gt; <a href="../../index.html" class="el_group">lab02-timeline</a> &gt; <a href="../index.html" class="el_bundle">src/test/java</a> &gt; <a href="index.source.html" class="el_package">com.uncooleben.dao</a> &gt; <span class="el_source">MessageSQLServerDAOTest.java</span></div><h1>MessageSQLServerDAOTest.java</h1><pre class="source lang-java linenums">package com.uncooleben.dao;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static org.mockito.Mockito.anyInt;
import static org.mockito.Mockito.anyString;
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.uncooleben.model.Message;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.List;
import java.util.UUID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InOrder;

<span class="fc" id="L34">public class MessageSQLServerDAOTest {</span>
  private MessageSQLServerDAO messageDAO;
<span class="fc" id="L36">  private Connection connection = mock(Connection.class);</span>
<span class="fc" id="L37">  private PreparedStatement pstmt = mock(PreparedStatement.class);</span>
<span class="fc" id="L38">  private Message message = mock(Message.class);</span>
<span class="fc" id="L39">  private ResultSet rs = mock(ResultSet.class);</span>
<span class="fc" id="L40">  private DateFormat dateFormatter = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span>
<span class="fc" id="L41">  private final String TEST_USERNAME = &quot;testUsername&quot;;</span>
<span class="fc" id="L42">  private final String TEST_CONTENT = &quot;testContent&quot;;</span>
<span class="fc" id="L43">  private final String TEST_UUID = &quot;0-0-0-0-0&quot;;</span>
<span class="fc" id="L44">  private final String TEST_TIME = &quot;2019-10-30 12:00:00&quot;;</span>
<span class="fc" id="L45">  private final long TEST_MILLISEC = 1572364800000L; // Equal to TEST_TIME</span>
<span class="fc" id="L46">  private final String TEST_USERNAME2 = &quot;testUsername2&quot;;</span>
<span class="fc" id="L47">  private final String TEST_CONTENT2 = &quot;testContent2&quot;;</span>
<span class="fc" id="L48">  private final String TEST_UUID2 = &quot;0-0-0-0-1&quot;;</span>
<span class="fc" id="L49">  private final String TEST_TIME2 = &quot;2019-10-30 08:00:00&quot;;</span>

<span class="fc" id="L51">  class MessageSQLServerDAOFake extends MessageSQLServerDAO {</span>
    @Override
<span class="nc" id="L53">    protected void loadDriver() {}</span>

    @Override
    protected Connection getConnection() {
<span class="fc" id="L57">      return connection;</span>
    }
  }

  @BeforeEach
  void init() {
<span class="fc" id="L63">    messageDAO = new MessageSQLServerDAOFake();</span>
<span class="fc" id="L64">  }</span>

  @Test
  void testStoreNullMessageThrowsException() {
<span class="pc" id="L68">    assertThrows(NullPointerException.class, () -&gt; messageDAO.storeMessage(null));</span>
<span class="fc" id="L69">  }</span>

  @Test
  void testStoreOneMessage() {
<span class="fc" id="L73">    String INSERT = &quot;INSERT INTO message(uuid, username, content, time) VALUES(?,?,?,?)&quot;;</span>
<span class="fc" id="L74">    Date date = mock(Date.class);</span>
<span class="fc" id="L75">    boolean succeed = false;</span>
    // Stub
    try {
<span class="fc" id="L78">      when(connection.prepareStatement(INSERT, Statement.RETURN_GENERATED_KEYS)).thenReturn(pstmt);</span>
<span class="fc" id="L79">      when(message.get_uuid()).thenReturn(UUID.fromString(TEST_UUID));</span>
<span class="fc" id="L80">      when(message.get_username()).thenReturn(TEST_USERNAME);</span>
<span class="fc" id="L81">      when(message.get_content()).thenReturn(TEST_CONTENT);</span>
<span class="fc" id="L82">      when(message.get_time()).thenReturn(date);</span>
<span class="pc" id="L83">    } catch (SQLException sqlE) {</span>
<span class="nc" id="L84">      System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L85">      fail(&quot;Exception occurs when stubbing.&quot;);</span>
    }
    // Test return value
<span class="fc" id="L88">    succeed = messageDAO.storeMessage(message);</span>
<span class="fc" id="L89">    assertTrue(succeed);</span>
    // Test function calls
    try {
<span class="fc" id="L92">      verify(connection).prepareStatement(INSERT, Statement.RETURN_GENERATED_KEYS);</span>
<span class="fc" id="L93">      verify(pstmt, times(4)).setString(anyInt(), anyString());</span>
<span class="fc" id="L94">      verify(pstmt).execute();</span>
<span class="fc" id="L95">      verify(pstmt).close();</span>
<span class="fc" id="L96">      verify(connection).close();</span>
<span class="pc" id="L97">    } catch (SQLException sqlE) {</span>
<span class="nc" id="L98">      System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L99">      fail(&quot;Exception occurs when testing function calls.&quot;);</span>
    }
    // Test function calls' order and capture arguments
<span class="fc" id="L102">    InOrder order = inOrder(pstmt, connection);</span>
<span class="fc" id="L103">    ArgumentCaptor&lt;String&gt; argsCap = ArgumentCaptor.forClass(String.class);</span>
    try {
<span class="fc" id="L105">      order.verify(connection).prepareStatement(INSERT, Statement.RETURN_GENERATED_KEYS);</span>
<span class="fc" id="L106">      order.verify(pstmt, times(4)).setString(anyInt(), argsCap.capture());</span>
<span class="fc" id="L107">      order.verify(pstmt).execute();</span>
<span class="fc" id="L108">      order.verify(pstmt).close();</span>
<span class="fc" id="L109">      order.verify(connection).close();</span>
<span class="fc" id="L110">      order.verifyNoMoreInteractions();</span>
<span class="pc" id="L111">    } catch (SQLException sqlE) {</span>
<span class="nc" id="L112">      System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L113">      fail(&quot;Exception occurs when testing function calls' order.&quot;);</span>
    }
    // Test arguments' order and value
<span class="fc" id="L116">    assertEquals(TEST_USERNAME, argsCap.getAllValues().get(1));</span>
<span class="fc" id="L117">    assertEquals(TEST_CONTENT, argsCap.getAllValues().get(2));</span>
<span class="fc" id="L118">  }</span>

  @Test
  void testStoreMessageThrowsSQLException() {
    // Change error output stream to capture error output
<span class="fc" id="L123">    ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L124">    PrintStream originalErr = System.err;</span>
<span class="fc" id="L125">    System.setErr(new PrintStream(errContent));</span>
    // Stub
    try {
<span class="fc" id="L128">      when(connection.prepareStatement(anyString(), anyInt())).thenThrow(SQLException.class);</span>
<span class="pc" id="L129">    } catch (SQLException sqlE) {</span>
<span class="nc" id="L130">      System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L131">      fail(&quot;Exception occurs when stubbing.&quot;);</span>
    }
    // Test return value
<span class="fc" id="L134">    boolean succeed = true;</span>
<span class="fc" id="L135">    succeed = messageDAO.storeMessage(message);</span>
<span class="fc" id="L136">    assertFalse(succeed);</span>
    // Test error output
<span class="fc" id="L138">    assertTrue(errContent.toString().contains(&quot;java.sql.SQLException&quot;));</span>
    // Change error output stream back to default
<span class="fc" id="L140">    System.setErr(originalErr);</span>
<span class="fc" id="L141">  }</span>

  @Test
  void testQueryMessageByUUID() {
<span class="fc" id="L145">    String SELECT = &quot;SELECT * FROM message WHERE uuid=(?)&quot;;</span>
    // Stub
    try {
<span class="fc" id="L148">      when(connection.prepareStatement(SELECT, Statement.RETURN_GENERATED_KEYS)).thenReturn(pstmt);</span>
<span class="fc" id="L149">      when(pstmt.executeQuery()).thenReturn(rs);</span>
<span class="fc" id="L150">      when(rs.getString(&quot;uuid&quot;)).thenReturn(TEST_UUID);</span>
<span class="fc" id="L151">      when(rs.getString(&quot;username&quot;)).thenReturn(TEST_USERNAME);</span>
<span class="fc" id="L152">      when(rs.getString(&quot;content&quot;)).thenReturn(TEST_CONTENT);</span>
<span class="fc" id="L153">      when(rs.getString(&quot;time&quot;)).thenReturn(TEST_TIME);</span>
<span class="fc" id="L154">      when(rs.next()).thenReturn(true, false); // Only one item in ResultSet</span>
<span class="pc" id="L155">    } catch (SQLException sqlE) {</span>
<span class="nc" id="L156">      System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L157">      fail(&quot;Exception occurs when stubbing.&quot;);</span>
    }
    // Test return value
<span class="fc" id="L160">    List&lt;Message&gt; resultList = messageDAO.queryMessageByUUID(UUID.fromString(TEST_UUID));</span>
<span class="fc" id="L161">    assertEquals(1, resultList.size());</span>
<span class="fc" id="L162">    assertEquals(UUID.fromString(TEST_UUID), resultList.get(0).get_uuid());</span>
<span class="fc" id="L163">    assertEquals(TEST_USERNAME, resultList.get(0).get_username());</span>
<span class="fc" id="L164">    assertEquals(TEST_CONTENT, resultList.get(0).get_content());</span>
<span class="fc" id="L165">    assertEquals(TEST_TIME, dateFormatter.format(resultList.get(0).get_time()));</span>
    // Test function calls' order
<span class="fc" id="L167">    InOrder order = inOrder(connection, pstmt, rs);</span>
    try {
<span class="fc" id="L169">      order.verify(connection).prepareStatement(SELECT, Statement.RETURN_GENERATED_KEYS);</span>
<span class="fc" id="L170">      order.verify(pstmt).executeQuery();</span>
<span class="fc" id="L171">      order.verify(rs).next();</span>
<span class="fc" id="L172">      order.verify(rs, times(4)).getString(anyString());</span>
<span class="pc" id="L173">    } catch (SQLException sqlE) {</span>
<span class="nc" id="L174">      System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L175">      fail(&quot;Exception occurs when testing function calls' order.&quot;);</span>
    }
<span class="fc" id="L177">  }</span>

  @Test
  void testQueryMessageByNullUUIDThrowsException() {
<span class="pc" id="L181">    assertThrows(NullPointerException.class, () -&gt; messageDAO.queryMessageByUUID(null));</span>
<span class="fc" id="L182">  }</span>

  @Test
  void testQueryMessageByUUIDThrowsSQLExceptionWhenPreparingStatement() {
    // Change error output stream to capture error output
<span class="fc" id="L187">    ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L188">    PrintStream originalErr = System.err;</span>
<span class="fc" id="L189">    System.setErr(new PrintStream(errContent));</span>
    // Stub
    try {
<span class="fc" id="L192">      when(connection.prepareStatement(anyString(), anyInt())).thenThrow(SQLException.class);</span>
<span class="pc" id="L193">    } catch (SQLException sqlE) {</span>
<span class="nc" id="L194">      System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L195">      fail(&quot;Exception occurs when stubbing.&quot;);</span>
    }
    // Test return value
<span class="fc" id="L198">    List&lt;Message&gt; resultList = messageDAO.queryMessageByUUID(UUID.fromString(TEST_UUID));</span>
<span class="fc" id="L199">    assertTrue(resultList.isEmpty()); // resultList should be empty</span>
    // Test error output
<span class="fc" id="L201">    assertTrue(errContent.toString().contains(&quot;java.sql.SQLException&quot;));</span>
    // Change error output stream back to default
<span class="fc" id="L203">    System.setErr(originalErr);</span>
<span class="fc" id="L204">  }</span>

  @Test
  void testQueryMessageByUUIDThrowsSQLExceptionWhenExecutingQuery() {
    // Change error output stream to capture error output
<span class="fc" id="L209">    ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L210">    PrintStream originalErr = System.err;</span>
<span class="fc" id="L211">    System.setErr(new PrintStream(errContent));</span>
    // Stub
    try {
<span class="fc" id="L214">      when(connection.prepareStatement(anyString(), anyInt())).thenReturn(pstmt);</span>
<span class="fc" id="L215">      when(pstmt.executeQuery()).thenThrow(SQLException.class);</span>
<span class="pc" id="L216">    } catch (SQLException sqlE) {</span>
<span class="nc" id="L217">      System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L218">      fail(&quot;Exception occurs when stubbing.&quot;);</span>
    }
    // Test return value
<span class="fc" id="L221">    List&lt;Message&gt; resultList = messageDAO.queryMessageByUUID(UUID.fromString(TEST_UUID));</span>
<span class="fc" id="L222">    assertTrue(resultList.isEmpty()); // resultList should be empty</span>
    // Test error output
<span class="fc" id="L224">    assertTrue(errContent.toString().contains(&quot;java.sql.SQLException&quot;));</span>
    // Change error output stream back to default
<span class="fc" id="L226">    System.setErr(originalErr);</span>
<span class="fc" id="L227">  }</span>

  @Test
  void testQueryMessageWithSize1AndMillisec1572364800000() {
<span class="fc" id="L231">    String SELECT = &quot;SELECT TOP 1 * FROM message WHERE time &lt;= ? ORDER BY time DESC&quot;;</span>
    // Stub
    try {
<span class="fc" id="L234">      when(connection.prepareStatement(SELECT, Statement.RETURN_GENERATED_KEYS)).thenReturn(pstmt);</span>
<span class="fc" id="L235">      when(pstmt.executeQuery()).thenReturn(rs);</span>
<span class="fc" id="L236">      when(rs.next()).thenReturn(true, false); // rs has only 1 item</span>
<span class="fc" id="L237">      when(rs.getString(&quot;uuid&quot;)).thenReturn(TEST_UUID);</span>
<span class="fc" id="L238">      when(rs.getString(&quot;username&quot;)).thenReturn(TEST_USERNAME);</span>
<span class="fc" id="L239">      when(rs.getString(&quot;content&quot;)).thenReturn(TEST_CONTENT);</span>
<span class="fc" id="L240">      when(rs.getString(&quot;time&quot;)).thenReturn(TEST_TIME);</span>
<span class="pc" id="L241">    } catch (SQLException sqlE) {</span>
<span class="nc" id="L242">      System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L243">      fail(&quot;Exception occurs when stubbing&quot;);</span>
    }
    // Test return value
<span class="fc" id="L246">    List&lt;Message&gt; resultList = messageDAO.queryMessage(1, TEST_MILLISEC);</span>
<span class="fc" id="L247">    assertEquals(1, resultList.size());</span>
<span class="fc" id="L248">    assertEquals(UUID.fromString(TEST_UUID), resultList.get(0).get_uuid());</span>
<span class="fc" id="L249">    assertEquals(TEST_USERNAME, resultList.get(0).get_username());</span>
<span class="fc" id="L250">    assertEquals(TEST_CONTENT, resultList.get(0).get_content());</span>
<span class="fc" id="L251">    assertEquals(TEST_TIME, dateFormatter.format(resultList.get(0).get_time()));</span>
    // Test function calls' order
<span class="fc" id="L253">    InOrder order = inOrder(connection, pstmt, rs);</span>
    try {
<span class="fc" id="L255">      order.verify(connection).prepareStatement(SELECT, Statement.RETURN_GENERATED_KEYS);</span>
<span class="fc" id="L256">      order.verify(pstmt).executeQuery();</span>
<span class="fc" id="L257">      order.verify(rs).next();</span>
<span class="fc" id="L258">      order.verify(rs, times(4)).getString(anyString());</span>
<span class="fc" id="L259">      order.verify(rs).next();</span>
<span class="fc" id="L260">      order.verify(pstmt).close();</span>
<span class="fc" id="L261">      order.verify(connection).close();</span>
<span class="fc" id="L262">      order.verifyNoMoreInteractions();</span>
<span class="pc" id="L263">    } catch (SQLException sqlE) {</span>
<span class="nc" id="L264">      System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L265">      fail(&quot;Exception occurs when testing function calls' order&quot;);</span>
    }
<span class="fc" id="L267">  }</span>

  @Test
  void testQueryMessageWithSize2AndMillisec1572364800000() {
<span class="fc" id="L271">    String SELECT = &quot;SELECT TOP 2 * FROM message WHERE time &lt;= ? ORDER BY time DESC&quot;;</span>
    // Stub
    try {
<span class="fc" id="L274">      when(connection.prepareStatement(SELECT, Statement.RETURN_GENERATED_KEYS)).thenReturn(pstmt);</span>
<span class="fc" id="L275">      when(pstmt.executeQuery()).thenReturn(rs);</span>
<span class="fc" id="L276">      when(rs.next()).thenReturn(true, true,false); // rs has 2 items</span>
<span class="fc" id="L277">      when(rs.getString(&quot;uuid&quot;)).thenReturn(TEST_UUID,TEST_UUID2);</span>
<span class="fc" id="L278">      when(rs.getString(&quot;username&quot;)).thenReturn(TEST_USERNAME,TEST_USERNAME2);</span>
<span class="fc" id="L279">      when(rs.getString(&quot;content&quot;)).thenReturn(TEST_CONTENT,TEST_CONTENT2);</span>
<span class="fc" id="L280">      when(rs.getString(&quot;time&quot;)).thenReturn(TEST_TIME,TEST_TIME2);</span>
<span class="pc" id="L281">    } catch (SQLException sqlE) {</span>
<span class="nc" id="L282">      System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L283">      fail(&quot;Exception occurs when stubbing&quot;);</span>
    }
    // Test return value
<span class="fc" id="L286">    List&lt;Message&gt; resultList = messageDAO.queryMessage(2, TEST_MILLISEC);</span>
<span class="fc" id="L287">    assertEquals(2, resultList.size());</span>
<span class="fc" id="L288">    assertEquals(UUID.fromString(TEST_UUID), resultList.get(0).get_uuid());</span>
<span class="fc" id="L289">    assertEquals(TEST_USERNAME, resultList.get(0).get_username());</span>
<span class="fc" id="L290">    assertEquals(TEST_CONTENT, resultList.get(0).get_content());</span>
<span class="fc" id="L291">    assertEquals(TEST_TIME, dateFormatter.format(resultList.get(0).get_time()));</span>
<span class="fc" id="L292">    assertEquals(UUID.fromString(TEST_UUID2), resultList.get(1).get_uuid());</span>
<span class="fc" id="L293">    assertEquals(TEST_USERNAME2, resultList.get(1).get_username());</span>
<span class="fc" id="L294">    assertEquals(TEST_CONTENT2, resultList.get(1).get_content());</span>
<span class="fc" id="L295">    assertEquals(TEST_TIME2, dateFormatter.format(resultList.get(1).get_time()));</span>
    // Test function calls' order
<span class="fc" id="L297">    InOrder order = inOrder(connection, pstmt, rs);</span>
    try {
<span class="fc" id="L299">      order.verify(connection).prepareStatement(SELECT, Statement.RETURN_GENERATED_KEYS);</span>
<span class="fc" id="L300">      order.verify(pstmt).executeQuery();</span>
<span class="fc" id="L301">      order.verify(rs).next();</span>
<span class="fc" id="L302">      order.verify(rs, times(4)).getString(anyString());</span>
<span class="fc" id="L303">      order.verify(rs).next();</span>
<span class="fc" id="L304">      order.verify(rs, times(4)).getString(anyString());</span>
<span class="fc" id="L305">      order.verify(rs).next();</span>
<span class="fc" id="L306">      order.verify(pstmt).close();</span>
<span class="fc" id="L307">      order.verify(connection).close();</span>
<span class="fc" id="L308">      order.verifyNoMoreInteractions();</span>
<span class="pc" id="L309">    } catch (SQLException sqlE) {</span>
<span class="nc" id="L310">      System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L311">      fail(&quot;Exception occurs when testing function calls' order&quot;);</span>
    }
<span class="fc" id="L313">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span>com.uncooleben.dao (Nov 8, 2019 11:51:39 PM)</div></body></html>