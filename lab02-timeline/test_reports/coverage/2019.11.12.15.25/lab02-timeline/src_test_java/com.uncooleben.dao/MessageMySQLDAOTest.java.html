<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>MessageMySQLDAOTest.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">lab02-timeline (1) (Nov 12, 2019 3:24:36 PM)</a> &gt; <a href="../../index.html" class="el_group">lab02-timeline</a> &gt; <a href="../index.html" class="el_bundle">src/test/java</a> &gt; <a href="index.source.html" class="el_package">com.uncooleben.dao</a> &gt; <span class="el_source">MessageMySQLDAOTest.java</span></div><h1>MessageMySQLDAOTest.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">package com.uncooleben.dao;</span>

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import java.util.function.Supplier;
import java.util.stream.Stream;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;

import com.uncooleben.model.Message;
import com.uncooleben.service.dao.MessageMySQLDAO;

<span class="fc" id="L37">public class MessageMySQLDAOTest {</span>

<span class="fc" id="L39">	private Connection connection = mock(Connection.class);</span>
<span class="fc" id="L40">	private PreparedStatement pstmt = mock(PreparedStatement.class);</span>
	private MessageMySQLDAO messageDAO;
	private long milliTime;
	private SimpleDateFormat format;

<span class="fc" id="L45">	class TestableMessageMySQLDAO extends MessageMySQLDAO {</span>

		@Override
		protected void loadDriver() {

<span class="nc" id="L50">		}</span>

		@Override
		protected Connection getConnection() throws SQLException {
<span class="fc" id="L54">			return connection;</span>
		}
	}

	@BeforeEach
	public void init() {
<span class="fc" id="L60">		this.messageDAO = new TestableMessageMySQLDAO();</span>
<span class="fc" id="L61">		this.milliTime = System.currentTimeMillis();</span>
<span class="fc" id="L62">		this.format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span>
<span class="fc" id="L63">	}</span>

	@Test
	public void test_sql_exception_store_message() {
<span class="fc" id="L67">		ByteArrayOutputStream outContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L68">		ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L69">		PrintStream originalOut = System.out;</span>
<span class="fc" id="L70">		PrintStream originalErr = System.err;</span>
<span class="fc" id="L71">		System.setOut(new PrintStream(outContent));</span>
<span class="fc" id="L72">		System.setErr(new PrintStream(errContent));</span>
<span class="fc" id="L73">		SQLException test_sqle = new SQLException();</span>
		try {
<span class="fc" id="L75">			when(connection.prepareStatement(anyString(), anyInt())).thenThrow(test_sqle);</span>
<span class="pc" id="L76">		} catch (SQLException sqle) {</span>
			// Won't throw any exception in this try/catch block
<span class="nc" id="L78">			sqle.printStackTrace(System.err);</span>
		}

<span class="fc" id="L81">		this.messageDAO.storeMessage(null, false);</span>
<span class="fc" id="L82">		assertTrue(errContent.toString().contains(&quot;java.sql.SQLException&quot;));</span>
<span class="fc" id="L83">		System.setOut(originalOut);</span>
<span class="fc" id="L84">		System.setErr(originalErr);</span>
<span class="fc" id="L85">	}</span>

	@Test
	public void test_store_one_message_without_image() {
<span class="fc" id="L89">		Date date = new Date(milliTime);</span>
<span class="fc" id="L90">		Message message = new Message(&quot;james&quot;, &quot;im bond&quot;, date);</span>
		// Creating argument captors for verification
<span class="fc" id="L92">		ArgumentCaptor&lt;String&gt; stringArgumentCaptor = ArgumentCaptor.forClass(String.class);</span>
<span class="fc" id="L93">		ArgumentCaptor&lt;Boolean&gt; booleanArgumentCaptor = ArgumentCaptor.forClass(Boolean.class);</span>
		// Mocking behaviours
		try {
<span class="fc" id="L96">			when(connection.prepareStatement(anyString(), anyInt())).thenReturn(pstmt);</span>
<span class="pc" id="L97">		} catch (SQLException sqle) {</span>
<span class="nc" id="L98">			sqle.printStackTrace(System.err);</span>
		}
		// Run the method
<span class="fc" id="L101">		boolean succeeded = this.messageDAO.storeMessage(message, false);</span>
		// Assertions
<span class="fc" id="L103">		assertTrue(succeeded);</span>
		try {
<span class="fc" id="L105">			verify(pstmt, times(5)).setString(anyInt(), stringArgumentCaptor.capture());</span>
<span class="fc" id="L106">			verify(pstmt, times(1)).setBoolean(anyInt(), booleanArgumentCaptor.capture());</span>
<span class="fc" id="L107">			assertEquals(&quot;james&quot;, stringArgumentCaptor.getAllValues().get(1));</span>
<span class="fc" id="L108">			assertEquals(&quot;im bond&quot;, stringArgumentCaptor.getAllValues().get(2));</span>
<span class="fc" id="L109">			assertEquals(null, stringArgumentCaptor.getAllValues().get(4));</span>
<span class="fc" id="L110">			assertEquals(false, booleanArgumentCaptor.getAllValues().get(0));</span>
<span class="pc" id="L111">		} catch (SQLException sqle) {</span>
<span class="nc" id="L112">			sqle.printStackTrace(System.err);</span>
<span class="nc" id="L113">			fail(&quot;Encountered SQLException when verifying arguments of pstmt, see below stack trace for detail.&quot;);</span>
		}

<span class="fc" id="L116">	}</span>

	@Test
	public void test_store_one_message_with_image() {
<span class="fc" id="L120">		Date date = new Date(milliTime);</span>
<span class="fc" id="L121">		Message message = new Message(&quot;james&quot;, &quot;im bond&quot;, date);</span>
		// Creating argument captors for verification
<span class="fc" id="L123">		ArgumentCaptor&lt;String&gt; stringArgumentCaptor = ArgumentCaptor.forClass(String.class);</span>
<span class="fc" id="L124">		ArgumentCaptor&lt;Boolean&gt; booleanArgumentCaptor = ArgumentCaptor.forClass(Boolean.class);</span>
		// Mocking behaviours
		try {
<span class="fc" id="L127">			when(connection.prepareStatement(anyString(), anyInt())).thenReturn(pstmt);</span>
<span class="pc" id="L128">		} catch (SQLException sqle) {</span>
<span class="nc" id="L129">			sqle.printStackTrace(System.err);</span>
		}
		// Run the method
<span class="fc" id="L132">		boolean succeeded = this.messageDAO.storeMessage(message, true);</span>
		// Assertions
<span class="fc" id="L134">		assertTrue(succeeded);</span>
		try {
<span class="fc" id="L136">			verify(pstmt, times(5)).setString(anyInt(), stringArgumentCaptor.capture());</span>
<span class="fc" id="L137">			verify(pstmt, times(1)).setBoolean(anyInt(), booleanArgumentCaptor.capture());</span>
<span class="fc" id="L138">			assertEquals(&quot;james&quot;, stringArgumentCaptor.getAllValues().get(1));</span>
<span class="fc" id="L139">			assertEquals(&quot;im bond&quot;, stringArgumentCaptor.getAllValues().get(2));</span>
<span class="fc" id="L140">			assertEquals(System.getenv(&quot;TEMP&quot;) + &quot;\\timeline_imgs&quot;, stringArgumentCaptor.getAllValues().get(4));</span>
<span class="fc" id="L141">			assertEquals(true, booleanArgumentCaptor.getAllValues().get(0));</span>
<span class="pc" id="L142">		} catch (SQLException sqle) {</span>
<span class="nc" id="L143">			sqle.printStackTrace(System.err);</span>
<span class="nc" id="L144">			fail(&quot;Encountered SQLException when verifying arguments of pstmt, see below stack trace for detail.&quot;);</span>
		}

<span class="fc" id="L147">	}</span>

	@Test
	public void test_sql_exception_query_by_uuid() {
<span class="fc" id="L151">		ByteArrayOutputStream outContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L152">		ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L153">		PrintStream originalOut = System.out;</span>
<span class="fc" id="L154">		PrintStream originalErr = System.err;</span>
<span class="fc" id="L155">		System.setOut(new PrintStream(outContent));</span>
<span class="fc" id="L156">		System.setErr(new PrintStream(errContent));</span>
<span class="fc" id="L157">		SQLException test_sqle = new SQLException();</span>
		try {
<span class="fc" id="L159">			when(connection.prepareStatement(anyString(), anyInt())).thenThrow(test_sqle);</span>
<span class="pc" id="L160">		} catch (SQLException sqle) {</span>
			// Won't throw any exception in this try/catch block
<span class="nc" id="L162">			sqle.printStackTrace(System.err);</span>
		}

<span class="fc" id="L165">		this.messageDAO.queryMessageByUUID(null);</span>
<span class="fc" id="L166">		assertTrue(errContent.toString().contains(&quot;java.sql.SQLException&quot;));</span>
<span class="fc" id="L167">		System.setOut(originalOut);</span>
<span class="fc" id="L168">		System.setErr(originalErr);</span>
<span class="fc" id="L169">	}</span>

	@Test
	public void test_parse_exception_query_by_uuid() {
<span class="fc" id="L173">		ByteArrayOutputStream outContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L174">		ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L175">		PrintStream originalOut = System.out;</span>
<span class="fc" id="L176">		PrintStream originalErr = System.err;</span>
<span class="fc" id="L177">		System.setOut(new PrintStream(outContent));</span>
<span class="fc" id="L178">		System.setErr(new PrintStream(errContent));</span>
<span class="fc" id="L179">		UUID uuid = UUID.randomUUID();</span>
<span class="fc" id="L180">		String uuid_str = uuid.toString();</span>
<span class="fc" id="L181">		String username = &quot;james bond&quot;;</span>
<span class="fc" id="L182">		String content = &quot;hello&quot;;</span>
<span class="fc" id="L183">		String time = &quot;MALFORMED DATE STRING&quot;;</span>
<span class="fc" id="L184">		ResultSet rs = mock(ResultSet.class);</span>
		try {
<span class="fc" id="L186">			when(connection.prepareStatement(anyString(), anyInt())).thenReturn(pstmt);</span>
<span class="fc" id="L187">			when(pstmt.executeQuery()).thenReturn(rs);</span>
<span class="fc" id="L188">			when(rs.next()).thenReturn(true, false); // First call returns true, second call returns false</span>
<span class="fc" id="L189">			when(rs.getString(&quot;uuid&quot;)).thenReturn(uuid_str);</span>
<span class="fc" id="L190">			when(rs.getString(&quot;username&quot;)).thenReturn(username);</span>
<span class="fc" id="L191">			when(rs.getString(&quot;content&quot;)).thenReturn(content);</span>
<span class="fc" id="L192">			when(rs.getString(&quot;time&quot;)).thenReturn(time);</span>
<span class="pc" id="L193">		} catch (SQLException sqle) {</span>
			// Won't throw any exception in this try/catch block
<span class="nc" id="L195">			sqle.printStackTrace(System.err);</span>
		}
<span class="fc" id="L197">		this.messageDAO.queryMessageByUUID(uuid);</span>
<span class="fc" id="L198">		assertTrue(errContent.toString().contains(&quot;java.text.ParseException&quot;));</span>
<span class="fc" id="L199">		System.setOut(originalOut);</span>
<span class="fc" id="L200">		System.setErr(originalErr);</span>
<span class="fc" id="L201">	}</span>

	@Test
	public void test_query_message_by_UUID() {
<span class="fc" id="L205">		UUID uuid = UUID.randomUUID();</span>
<span class="fc" id="L206">		String uuid_str = uuid.toString();</span>
<span class="fc" id="L207">		String username = &quot;james bond&quot;;</span>
<span class="fc" id="L208">		String content = &quot;hello&quot;;</span>
<span class="fc" id="L209">		String time = this.format.format(new Date(this.milliTime));</span>
<span class="fc" id="L210">		ResultSet rs = mock(ResultSet.class);</span>
		try {
<span class="fc" id="L212">			when(connection.prepareStatement(anyString(), anyInt())).thenReturn(pstmt);</span>
<span class="fc" id="L213">			when(pstmt.executeQuery()).thenReturn(rs);</span>
<span class="fc" id="L214">			when(rs.next()).thenReturn(true, false); // First call returns true, second call returns false</span>
<span class="fc" id="L215">			when(rs.getString(&quot;uuid&quot;)).thenReturn(uuid_str);</span>
<span class="fc" id="L216">			when(rs.getString(&quot;username&quot;)).thenReturn(username);</span>
<span class="fc" id="L217">			when(rs.getString(&quot;content&quot;)).thenReturn(content);</span>
<span class="fc" id="L218">			when(rs.getString(&quot;time&quot;)).thenReturn(time);</span>
<span class="pc" id="L219">		} catch (SQLException sqle) {</span>
<span class="nc" id="L220">			sqle.printStackTrace(System.err);</span>
		}
<span class="fc" id="L222">		List&lt;Message&gt; result_list = this.messageDAO.queryMessageByUUID(uuid);</span>
<span class="fc" id="L223">		assertEquals(1, result_list.size());</span>
<span class="fc" id="L224">		Message result_message = result_list.get(0);</span>
<span class="fc" id="L225">		assertEquals(uuid, result_message.get_uuid());</span>
<span class="fc" id="L226">		assertEquals(username, result_message.get_username());</span>
<span class="fc" id="L227">		assertEquals(content, result_message.get_content());</span>
<span class="fc" id="L228">		assertEquals(time, format.format(result_message.get_time()));</span>
		// Creating argument captors for verification
<span class="fc" id="L230">		ArgumentCaptor&lt;String&gt; stringArgumentCaptor = ArgumentCaptor.forClass(String.class);</span>
		try {
<span class="fc" id="L232">			verify(pstmt, times(1)).setString(anyInt(), stringArgumentCaptor.capture());</span>
<span class="fc" id="L233">			assertEquals(uuid_str, stringArgumentCaptor.getAllValues().get(0));</span>
<span class="pc" id="L234">		} catch (SQLException sqle) {</span>
<span class="nc" id="L235">			sqle.printStackTrace(System.err);</span>
<span class="nc" id="L236">			fail(&quot;Encountered SQLException when verifying arguments of pstmt, see below stack trace for detail.&quot;);</span>
		}

<span class="fc" id="L239">	}</span>

	@Test
	public void test_sql_exception_query_message() {
<span class="fc" id="L243">		ByteArrayOutputStream outContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L244">		ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L245">		PrintStream originalOut = System.out;</span>
<span class="fc" id="L246">		PrintStream originalErr = System.err;</span>
<span class="fc" id="L247">		System.setOut(new PrintStream(outContent));</span>
<span class="fc" id="L248">		System.setErr(new PrintStream(errContent));</span>
<span class="fc" id="L249">		SQLException test_sqle = new SQLException();</span>
		try {
<span class="fc" id="L251">			when(connection.prepareStatement(anyString(), anyInt())).thenThrow(test_sqle);</span>
<span class="pc" id="L252">		} catch (SQLException sqle) {</span>
			// Won't throw any exception in this try/catch block
<span class="nc" id="L254">			sqle.printStackTrace(System.err);</span>
		}

<span class="fc" id="L257">		this.messageDAO.queryMessage(0, 0L);</span>
<span class="fc" id="L258">		assertTrue(errContent.toString().contains(&quot;java.sql.SQLException&quot;));</span>
<span class="fc" id="L259">		System.setOut(originalOut);</span>
<span class="fc" id="L260">		System.setErr(originalErr);</span>
<span class="fc" id="L261">	}</span>

	@Test
	public void test_parse_exception_query_message() {
<span class="fc" id="L265">		ByteArrayOutputStream outContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L266">		ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L267">		PrintStream originalOut = System.out;</span>
<span class="fc" id="L268">		PrintStream originalErr = System.err;</span>
<span class="fc" id="L269">		System.setOut(new PrintStream(outContent));</span>
<span class="fc" id="L270">		System.setErr(new PrintStream(errContent));</span>
<span class="fc" id="L271">		UUID uuid = UUID.randomUUID();</span>
<span class="fc" id="L272">		String uuid_str = uuid.toString();</span>
<span class="fc" id="L273">		String username = &quot;james bond&quot;;</span>
<span class="fc" id="L274">		String content = &quot;hello&quot;;</span>
<span class="fc" id="L275">		String time = &quot;MALFORMED DATE STRING&quot;;</span>
<span class="fc" id="L276">		ResultSet rs = mock(ResultSet.class);</span>
		try {
<span class="fc" id="L278">			when(connection.prepareStatement(anyString(), anyInt())).thenReturn(pstmt);</span>
<span class="fc" id="L279">			when(pstmt.executeQuery()).thenReturn(rs);</span>
<span class="fc" id="L280">			when(rs.next()).thenReturn(true, false); // First call returns true, second call returns false</span>
<span class="fc" id="L281">			when(rs.getString(&quot;uuid&quot;)).thenReturn(uuid_str);</span>
<span class="fc" id="L282">			when(rs.getString(&quot;username&quot;)).thenReturn(username);</span>
<span class="fc" id="L283">			when(rs.getString(&quot;content&quot;)).thenReturn(content);</span>
<span class="fc" id="L284">			when(rs.getString(&quot;time&quot;)).thenReturn(time);</span>
<span class="pc" id="L285">		} catch (SQLException sqle) {</span>
			// Won't throw any exception in this try/catch block
<span class="nc" id="L287">			sqle.printStackTrace(System.err);</span>
		}
<span class="fc" id="L289">		this.messageDAO.queryMessage(0, 0L);</span>
<span class="fc" id="L290">		assertTrue(errContent.toString().contains(&quot;java.text.ParseException&quot;));</span>
<span class="fc" id="L291">		System.setOut(originalOut);</span>
<span class="fc" id="L292">		System.setErr(originalErr);</span>
<span class="fc" id="L293">	}</span>

	@Test
	public void test_query_message() {
<span class="fc" id="L297">		List&lt;Message&gt; expected = new ArrayList&lt;Message&gt;(5);</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">		for (int index = 0; index &lt; 5; index++) {</span>
<span class="fc" id="L299">			UUID uuid = UUID.randomUUID();</span>
<span class="fc" id="L300">			String username = &quot;USER&quot; + UUID.randomUUID().toString();</span>
<span class="fc" id="L301">			String content = &quot;CONTENT&quot; + UUID.randomUUID().toString();</span>
<span class="fc" id="L302">			Date time = new Date(this.milliTime);</span>
<span class="fc" id="L303">			Message newMessage = new Message(uuid, username, content, time);</span>
<span class="fc" id="L304">			expected.add(newMessage);</span>
		}
<span class="fc" id="L306">		Supplier&lt;Stream&lt;String&gt;&gt; uuids = () -&gt; expected.stream().map(Message::get_uuid).map(UUID::toString);</span>
<span class="fc" id="L307">		Supplier&lt;Stream&lt;String&gt;&gt; usernames = () -&gt; expected.stream().map(Message::get_username);</span>
<span class="fc" id="L308">		Supplier&lt;Stream&lt;String&gt;&gt; contents = () -&gt; expected.stream().map(Message::get_content);</span>
<span class="fc" id="L309">		Supplier&lt;Stream&lt;String&gt;&gt; times = () -&gt; expected.stream().map(Message::get_time)</span>
<span class="fc" id="L310">				.map(date -&gt; (this.format.format(date)));</span>
<span class="fc" id="L311">		ResultSet rs = mock(ResultSet.class);</span>
		try {
<span class="fc" id="L313">			when(connection.prepareStatement(anyString(), anyInt())).thenReturn(pstmt);</span>
<span class="fc" id="L314">			when(pstmt.executeQuery()).thenReturn(rs);</span>
<span class="fc" id="L315">			when(rs.next()).thenReturn(true, new Boolean[] { true, true, true, true, false }); // First call returns</span>
																								// true, second call
																								// returns false
<span class="fc" id="L318">			when(rs.getString(&quot;uuid&quot;)).thenReturn(uuids.get().findFirst().get(),</span>
<span class="fc" id="L319">					uuids.get().skip(1).toArray(String[]::new));</span>
<span class="fc" id="L320">			when(rs.getString(&quot;username&quot;)).thenReturn(usernames.get().findFirst().get(),</span>
<span class="fc" id="L321">					usernames.get().skip(1).toArray(String[]::new));</span>
<span class="fc" id="L322">			when(rs.getString(&quot;content&quot;)).thenReturn(contents.get().findFirst().get(),</span>
<span class="fc" id="L323">					contents.get().skip(1).toArray(String[]::new));</span>
<span class="fc" id="L324">			when(rs.getString(&quot;time&quot;)).thenReturn(times.get().findFirst().get(),</span>
<span class="fc" id="L325">					times.get().skip(1).toArray(String[]::new));</span>
<span class="pc" id="L326">		} catch (SQLException sqle) {</span>
<span class="nc" id="L327">			sqle.printStackTrace(System.err);</span>
		}
<span class="fc" id="L329">		List&lt;Message&gt; actual = this.messageDAO.queryMessage(5, milliTime);</span>
<span class="fc" id="L330">		assertEquals(5, actual.size());</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">		for (int index = 0; index &lt; 5; ++index) {</span>
<span class="fc" id="L332">			assertEquals(expected.get(index), actual.get(index));</span>
		}
		// Creating argument captors for verification
<span class="fc" id="L335">		ArgumentCaptor&lt;String&gt; stringArgumentCaptor = ArgumentCaptor.forClass(String.class);</span>
<span class="fc" id="L336">		ArgumentCaptor&lt;Integer&gt; integerArgumentCaptor = ArgumentCaptor.forClass(Integer.class);</span>
		try {
<span class="fc" id="L338">			verify(pstmt, times(1)).setString(eq(1), stringArgumentCaptor.capture());</span>
<span class="fc" id="L339">			assertEquals(this.format.format(new Date(milliTime)), stringArgumentCaptor.getAllValues().get(0));</span>
<span class="fc" id="L340">			verify(pstmt, times(1)).setInt(eq(2), integerArgumentCaptor.capture());</span>
<span class="fc" id="L341">			assertEquals(5, integerArgumentCaptor.getAllValues().get(0));</span>
<span class="pc" id="L342">		} catch (SQLException sqle) {</span>
<span class="nc" id="L343">			sqle.printStackTrace(System.err);</span>
<span class="nc" id="L344">			fail(&quot;Encountered SQLException when verifying arguments of pstmt, see below stack trace for detail.&quot;);</span>
		}

<span class="fc" id="L347">	}</span>

	@Test
	public void test_sql_exception_query_updates() {
<span class="fc" id="L351">		ByteArrayOutputStream outContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L352">		ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L353">		PrintStream originalOut = System.out;</span>
<span class="fc" id="L354">		PrintStream originalErr = System.err;</span>
<span class="fc" id="L355">		System.setOut(new PrintStream(outContent));</span>
<span class="fc" id="L356">		System.setErr(new PrintStream(errContent));</span>
<span class="fc" id="L357">		SQLException test_sqle = new SQLException();</span>
		try {
<span class="fc" id="L359">			when(connection.prepareStatement(anyString(), anyInt())).thenThrow(test_sqle);</span>
<span class="pc" id="L360">		} catch (SQLException sqle) {</span>
			// Won't throw any exception in this try/catch block
<span class="nc" id="L362">			sqle.printStackTrace(System.err);</span>
		}

<span class="fc" id="L365">		this.messageDAO.queryUpdates(0L);</span>
<span class="fc" id="L366">		assertTrue(errContent.toString().contains(&quot;java.sql.SQLException&quot;));</span>
<span class="fc" id="L367">		System.setOut(originalOut);</span>
<span class="fc" id="L368">		System.setErr(originalErr);</span>
<span class="fc" id="L369">	}</span>

	@Test
	public void test_query_updates() {
<span class="fc" id="L373">		ResultSet rs = mock(ResultSet.class);</span>
<span class="fc" id="L374">		int expected = 5;</span>
		try {
<span class="fc" id="L376">			when(connection.prepareStatement(anyString(), anyInt())).thenReturn(pstmt);</span>
<span class="fc" id="L377">			when(pstmt.executeQuery()).thenReturn(rs);</span>
<span class="fc" id="L378">			when(rs.next()).thenReturn(true, false);</span>
<span class="fc" id="L379">			when(rs.getInt(1)).thenReturn(expected);</span>
<span class="pc" id="L380">		} catch (SQLException sqle) {</span>
<span class="nc" id="L381">			sqle.printStackTrace(System.err);</span>
		}
<span class="fc" id="L383">		int actual = this.messageDAO.queryUpdates(milliTime);</span>
<span class="fc" id="L384">		assertEquals(expected, actual);</span>
		// Creating argument captors for verification
<span class="fc" id="L386">		ArgumentCaptor&lt;String&gt; stringArgumentCaptor = ArgumentCaptor.forClass(String.class);</span>
		try {
<span class="fc" id="L388">			verify(pstmt, times(1)).setString(eq(1), stringArgumentCaptor.capture());</span>
<span class="fc" id="L389">			assertEquals(this.format.format(new Date(milliTime)), stringArgumentCaptor.getAllValues().get(0));</span>
<span class="pc" id="L390">		} catch (SQLException sqle) {</span>
<span class="nc" id="L391">			sqle.printStackTrace(System.err);</span>
<span class="nc" id="L392">			fail(&quot;Encountered SQLException when verifying arguments of pstmt, see below stack trace for detail.&quot;);</span>
		}

<span class="fc" id="L395">	}</span>

	@Test
	public void test_sql_exception_clear_table() {
<span class="fc" id="L399">		ByteArrayOutputStream outContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L400">		ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L401">		PrintStream originalOut = System.out;</span>
<span class="fc" id="L402">		PrintStream originalErr = System.err;</span>
<span class="fc" id="L403">		System.setOut(new PrintStream(outContent));</span>
<span class="fc" id="L404">		System.setErr(new PrintStream(errContent));</span>
<span class="fc" id="L405">		SQLException test_sqle = new SQLException();</span>
		try {
<span class="fc" id="L407">			when(connection.prepareStatement(anyString(), anyInt())).thenThrow(test_sqle);</span>
<span class="pc" id="L408">		} catch (SQLException sqle) {</span>
			// Won't throw any exception in this try/catch block
<span class="nc" id="L410">			sqle.printStackTrace(System.err);</span>
		}

<span class="fc" id="L413">		this.messageDAO.clearTable();</span>
<span class="fc" id="L414">		assertTrue(errContent.toString().contains(&quot;java.sql.SQLException&quot;));</span>
<span class="fc" id="L415">		System.setOut(originalOut);</span>
<span class="fc" id="L416">		System.setErr(originalErr);</span>
<span class="fc" id="L417">	}</span>

	@Test
	public void test_clear_table() {
		try {
<span class="fc" id="L422">			when(connection.prepareStatement(anyString(), anyInt())).thenReturn(pstmt);</span>
<span class="pc" id="L423">		} catch (SQLException sqle) {</span>
<span class="nc" id="L424">			sqle.printStackTrace(System.err);</span>
		}
<span class="fc" id="L426">		boolean success = this.messageDAO.clearTable();</span>
<span class="fc" id="L427">		assertTrue(success);</span>

<span class="fc" id="L429">	}</span>

	@Test
	public void test_sql_exception_close_statement() {
<span class="fc" id="L433">		ByteArrayOutputStream outContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L434">		ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L435">		PrintStream originalOut = System.out;</span>
<span class="fc" id="L436">		PrintStream originalErr = System.err;</span>
<span class="fc" id="L437">		System.setOut(new PrintStream(outContent));</span>
<span class="fc" id="L438">		System.setErr(new PrintStream(errContent));</span>
<span class="fc" id="L439">		SQLException test_sqle = new SQLException();</span>
		try {
<span class="fc" id="L441">			doThrow(test_sqle).when(pstmt).close();</span>
<span class="pc" id="L442">		} catch (SQLException sqle) {</span>
			// Won't throw any exception in this try/catch block
<span class="nc" id="L444">			sqle.printStackTrace(System.err);</span>
		}
<span class="fc" id="L446">		this.messageDAO.closeStatementAndConnection(pstmt, connection);</span>
<span class="fc" id="L447">		assertTrue(errContent.toString().contains(&quot;java.sql.SQLException&quot;));</span>
<span class="fc" id="L448">		System.setOut(originalOut);</span>
<span class="fc" id="L449">		System.setErr(originalErr);</span>
<span class="fc" id="L450">	}</span>

	@Test
	public void test_sql_exception_close_connection() {
<span class="fc" id="L454">		ByteArrayOutputStream outContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L455">		ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L456">		PrintStream originalOut = System.out;</span>
<span class="fc" id="L457">		PrintStream originalErr = System.err;</span>
<span class="fc" id="L458">		System.setOut(new PrintStream(outContent));</span>
<span class="fc" id="L459">		System.setErr(new PrintStream(errContent));</span>
<span class="fc" id="L460">		SQLException test_sqle = new SQLException();</span>
		try {
<span class="fc" id="L462">			doThrow(test_sqle).when(connection).close();</span>
<span class="pc" id="L463">		} catch (SQLException sqle) {</span>
			// Won't throw any exception in this try/catch block
<span class="nc" id="L465">			sqle.printStackTrace(System.err);</span>
		}
<span class="fc" id="L467">		this.messageDAO.closeStatementAndConnection(pstmt, connection);</span>
<span class="fc" id="L468">		assertTrue(errContent.toString().contains(&quot;java.sql.SQLException&quot;));</span>
<span class="fc" id="L469">		System.setOut(originalOut);</span>
<span class="fc" id="L470">		System.setErr(originalErr);</span>
<span class="fc" id="L471">	}</span>

	@AfterEach
	public void last() {

<span class="fc" id="L476">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span>lab02-timeline (1) (Nov 12, 2019 3:24:36 PM)</div></body></html>