<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>MessageSQLServerDAOTest.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">lab02-timeline (1) (Nov 12, 2019 3:24:36 PM)</a> &gt; <a href="../../index.html" class="el_group">lab02-timeline</a> &gt; <a href="../index.html" class="el_bundle">src/test/java</a> &gt; <a href="index.source.html" class="el_package">com.uncooleben.dao</a> &gt; <span class="el_source">MessageSQLServerDAOTest.java</span></div><h1>MessageSQLServerDAOTest.java</h1><pre class="source lang-java linenums">package com.uncooleben.dao;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.List;
import java.util.UUID;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InOrder;

import com.uncooleben.model.Message;
import com.uncooleben.service.dao.MessageSQLServerDAO;

<span class="fc" id="L37">public class MessageSQLServerDAOTest {</span>
	private MessageSQLServerDAO messageDAO;
<span class="fc" id="L39">	private Connection connection = mock(Connection.class);</span>
<span class="fc" id="L40">	private PreparedStatement pstmt = mock(PreparedStatement.class);</span>
<span class="fc" id="L41">	private Message message = mock(Message.class);</span>
<span class="fc" id="L42">	private ResultSet rs = mock(ResultSet.class);</span>
<span class="fc" id="L43">	private DateFormat dateFormatter = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);</span>
<span class="fc" id="L44">	private final String TEST_USERNAME = &quot;testUsername&quot;;</span>
<span class="fc" id="L45">	private final String TEST_CONTENT = &quot;testContent&quot;;</span>
<span class="fc" id="L46">	private final String TEST_UUID = &quot;0-0-0-0-0&quot;;</span>
<span class="fc" id="L47">	private final String TEST_TIME = &quot;2019-10-30 12:00:00&quot;;</span>
<span class="fc" id="L48">	private final long TEST_MILLISEC = 1572364800000L; // Equal to TEST_TIME</span>
<span class="fc" id="L49">	private final String TEST_USERNAME2 = &quot;testUsername2&quot;;</span>
<span class="fc" id="L50">	private final String TEST_CONTENT2 = &quot;testContent2&quot;;</span>
<span class="fc" id="L51">	private final String TEST_UUID2 = &quot;0-0-0-0-1&quot;;</span>
<span class="fc" id="L52">	private final String TEST_TIME2 = &quot;2019-10-30 08:00:00&quot;;</span>

<span class="fc" id="L54">	class MessageSQLServerDAOFake extends MessageSQLServerDAO {</span>
		@Override
		protected void loadDriver() {
<span class="nc" id="L57">		}</span>

		@Override
		protected Connection getConnection() {
<span class="fc" id="L61">			return connection;</span>
		}
	}

	@BeforeEach
	void init() {
<span class="fc" id="L67">		messageDAO = new MessageSQLServerDAOFake();</span>
<span class="fc" id="L68">	}</span>

	@Test
	void testStoreNullMessageThrowsException() {
<span class="pc" id="L72">		assertThrows(NullPointerException.class, () -&gt; messageDAO.storeMessage(null, false));</span>
<span class="fc" id="L73">	}</span>

	@Test
	void testStoreOneMessage() {
<span class="fc" id="L77">		String INSERT = &quot;INSERT INTO message(uuid, username, content, time, withImage, path) &quot; + &quot;VALUES(?,?,?,?,?,?)&quot;;</span>
<span class="fc" id="L78">		Date date = mock(Date.class);</span>
<span class="fc" id="L79">		boolean succeed = false;</span>
		// Stub
		try {
<span class="fc" id="L82">			when(connection.prepareStatement(INSERT, Statement.RETURN_GENERATED_KEYS)).thenReturn(pstmt);</span>
<span class="fc" id="L83">			when(message.get_uuid()).thenReturn(UUID.fromString(TEST_UUID));</span>
<span class="fc" id="L84">			when(message.get_username()).thenReturn(TEST_USERNAME);</span>
<span class="fc" id="L85">			when(message.get_content()).thenReturn(TEST_CONTENT);</span>
<span class="fc" id="L86">			when(message.get_time()).thenReturn(date);</span>
<span class="pc" id="L87">		} catch (SQLException sqlE) {</span>
<span class="nc" id="L88">			System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L89">			fail(&quot;Exception occurs when stubbing.&quot;);</span>
		}
		// Test return value
<span class="fc" id="L92">		succeed = messageDAO.storeMessage(message, false);</span>
<span class="fc" id="L93">		assertTrue(succeed);</span>
		// Test function calls
		try {
<span class="fc" id="L96">			verify(connection).prepareStatement(INSERT, Statement.RETURN_GENERATED_KEYS);</span>
<span class="fc" id="L97">			verify(pstmt, times(4)).setString(anyInt(), anyString());</span>
<span class="fc" id="L98">			verify(pstmt).execute();</span>
<span class="fc" id="L99">			verify(pstmt).close();</span>
<span class="fc" id="L100">			verify(connection).close();</span>
<span class="pc" id="L101">		} catch (SQLException sqlE) {</span>
<span class="nc" id="L102">			System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L103">			fail(&quot;Exception occurs when testing function calls.&quot;);</span>
		}
		// Test function calls' order and capture arguments
<span class="fc" id="L106">		InOrder order = inOrder(pstmt, connection);</span>
<span class="fc" id="L107">		ArgumentCaptor&lt;String&gt; argsCap = ArgumentCaptor.forClass(String.class);</span>
		try {
<span class="fc" id="L109">			order.verify(connection).prepareStatement(INSERT, Statement.RETURN_GENERATED_KEYS);</span>
<span class="fc" id="L110">			order.verify(pstmt, times(4)).setString(anyInt(), argsCap.capture());</span>
<span class="fc" id="L111">			order.verify(pstmt).execute();</span>
<span class="fc" id="L112">			order.verify(pstmt).close();</span>
<span class="fc" id="L113">			order.verify(connection).close();</span>
<span class="fc" id="L114">			order.verifyNoMoreInteractions();</span>
<span class="pc" id="L115">		} catch (SQLException sqlE) {</span>
<span class="nc" id="L116">			System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L117">			fail(&quot;Exception occurs when testing function calls' order.&quot;);</span>
		}
		// Test arguments' order and value
<span class="fc" id="L120">		assertEquals(TEST_USERNAME, argsCap.getAllValues().get(1));</span>
<span class="fc" id="L121">		assertEquals(TEST_CONTENT, argsCap.getAllValues().get(2));</span>
<span class="fc" id="L122">	}</span>

	@Test
	void testStoreMessageThrowsSQLException() {
		// Change error output stream to capture error output
<span class="fc" id="L127">		ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L128">		PrintStream originalErr = System.err;</span>
<span class="fc" id="L129">		System.setErr(new PrintStream(errContent));</span>
		// Stub
		try {
<span class="fc" id="L132">			when(connection.prepareStatement(anyString(), anyInt())).thenThrow(SQLException.class);</span>
<span class="pc" id="L133">		} catch (SQLException sqlE) {</span>
<span class="nc" id="L134">			System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L135">			fail(&quot;Exception occurs when stubbing.&quot;);</span>
		}
		// Test return value
<span class="fc" id="L138">		boolean succeed = true;</span>
<span class="fc" id="L139">		succeed = messageDAO.storeMessage(message, false);</span>
<span class="fc" id="L140">		assertFalse(succeed);</span>
		// Test error output
<span class="fc" id="L142">		assertTrue(errContent.toString().contains(&quot;java.sql.SQLException&quot;));</span>
		// Change error output stream back to default
<span class="fc" id="L144">		System.setErr(originalErr);</span>
<span class="fc" id="L145">	}</span>

	@Test
	void testQueryMessageByUUID() {
<span class="fc" id="L149">		String SELECT = &quot;SELECT * FROM message WHERE uuid=(?)&quot;;</span>
		// Stub
		try {
<span class="fc" id="L152">			when(connection.prepareStatement(SELECT, Statement.RETURN_GENERATED_KEYS)).thenReturn(pstmt);</span>
<span class="fc" id="L153">			when(pstmt.executeQuery()).thenReturn(rs);</span>
<span class="fc" id="L154">			when(rs.getString(&quot;uuid&quot;)).thenReturn(TEST_UUID);</span>
<span class="fc" id="L155">			when(rs.getString(&quot;username&quot;)).thenReturn(TEST_USERNAME);</span>
<span class="fc" id="L156">			when(rs.getString(&quot;content&quot;)).thenReturn(TEST_CONTENT);</span>
<span class="fc" id="L157">			when(rs.getString(&quot;time&quot;)).thenReturn(TEST_TIME);</span>
<span class="fc" id="L158">			when(rs.next()).thenReturn(true, false); // Only one item in ResultSet</span>
<span class="pc" id="L159">		} catch (SQLException sqlE) {</span>
<span class="nc" id="L160">			System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L161">			fail(&quot;Exception occurs when stubbing.&quot;);</span>
		}
		// Test return value
<span class="fc" id="L164">		List&lt;Message&gt; resultList = messageDAO.queryMessageByUUID(UUID.fromString(TEST_UUID));</span>
<span class="fc" id="L165">		assertEquals(1, resultList.size());</span>
<span class="fc" id="L166">		assertEquals(UUID.fromString(TEST_UUID), resultList.get(0).get_uuid());</span>
<span class="fc" id="L167">		assertEquals(TEST_USERNAME, resultList.get(0).get_username());</span>
<span class="fc" id="L168">		assertEquals(TEST_CONTENT, resultList.get(0).get_content());</span>
<span class="fc" id="L169">		assertEquals(TEST_TIME, dateFormatter.format(resultList.get(0).get_time()));</span>
		// Test function calls' order
<span class="fc" id="L171">		InOrder order = inOrder(connection, pstmt, rs);</span>
		try {
<span class="fc" id="L173">			order.verify(connection).prepareStatement(SELECT, Statement.RETURN_GENERATED_KEYS);</span>
<span class="fc" id="L174">			order.verify(pstmt).executeQuery();</span>
<span class="fc" id="L175">			order.verify(rs).next();</span>
<span class="fc" id="L176">			order.verify(rs, times(4)).getString(anyString());</span>
<span class="pc" id="L177">		} catch (SQLException sqlE) {</span>
<span class="nc" id="L178">			System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L179">			fail(&quot;Exception occurs when testing function calls' order.&quot;);</span>
		}
<span class="fc" id="L181">	}</span>

	@Test
	void testQueryMessageByNullUUIDThrowsException() {
<span class="pc" id="L185">		assertThrows(NullPointerException.class, () -&gt; messageDAO.queryMessageByUUID(null));</span>
<span class="fc" id="L186">	}</span>

	@Test
	void testQueryMessageByUUIDThrowsSQLExceptionWhenPreparingStatement() {
		// Change error output stream to capture error output
<span class="fc" id="L191">		ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L192">		PrintStream originalErr = System.err;</span>
<span class="fc" id="L193">		System.setErr(new PrintStream(errContent));</span>
		// Stub
		try {
<span class="fc" id="L196">			when(connection.prepareStatement(anyString(), anyInt())).thenThrow(SQLException.class);</span>
<span class="pc" id="L197">		} catch (SQLException sqlE) {</span>
<span class="nc" id="L198">			System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L199">			fail(&quot;Exception occurs when stubbing.&quot;);</span>
		}
		// Test return value
<span class="fc" id="L202">		List&lt;Message&gt; resultList = messageDAO.queryMessageByUUID(UUID.fromString(TEST_UUID));</span>
<span class="fc" id="L203">		assertTrue(resultList.isEmpty()); // resultList should be empty</span>
		// Test error output
<span class="fc" id="L205">		assertTrue(errContent.toString().contains(&quot;java.sql.SQLException&quot;));</span>
		// Change error output stream back to default
<span class="fc" id="L207">		System.setErr(originalErr);</span>
<span class="fc" id="L208">	}</span>

	@Test
	void testQueryMessageByUUIDThrowsSQLExceptionWhenExecutingQuery() {
		// Change error output stream to capture error output
<span class="fc" id="L213">		ByteArrayOutputStream errContent = new ByteArrayOutputStream();</span>
<span class="fc" id="L214">		PrintStream originalErr = System.err;</span>
<span class="fc" id="L215">		System.setErr(new PrintStream(errContent));</span>
		// Stub
		try {
<span class="fc" id="L218">			when(connection.prepareStatement(anyString(), anyInt())).thenReturn(pstmt);</span>
<span class="fc" id="L219">			when(pstmt.executeQuery()).thenThrow(SQLException.class);</span>
<span class="pc" id="L220">		} catch (SQLException sqlE) {</span>
<span class="nc" id="L221">			System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L222">			fail(&quot;Exception occurs when stubbing.&quot;);</span>
		}
		// Test return value
<span class="fc" id="L225">		List&lt;Message&gt; resultList = messageDAO.queryMessageByUUID(UUID.fromString(TEST_UUID));</span>
<span class="fc" id="L226">		assertTrue(resultList.isEmpty()); // resultList should be empty</span>
		// Test error output
<span class="fc" id="L228">		assertTrue(errContent.toString().contains(&quot;java.sql.SQLException&quot;));</span>
		// Change error output stream back to default
<span class="fc" id="L230">		System.setErr(originalErr);</span>
<span class="fc" id="L231">	}</span>

	@Test
	void testQueryMessageWithSize1AndMillisec1572364800000() {
<span class="fc" id="L235">		String SELECT = &quot;SELECT TOP 1 * FROM message WHERE time &lt;= ? ORDER BY time DESC&quot;;</span>
		// Stub
		try {
<span class="fc" id="L238">			when(connection.prepareStatement(SELECT, Statement.RETURN_GENERATED_KEYS)).thenReturn(pstmt);</span>
<span class="fc" id="L239">			when(pstmt.executeQuery()).thenReturn(rs);</span>
<span class="fc" id="L240">			when(rs.next()).thenReturn(true, false); // rs has only 1 item</span>
<span class="fc" id="L241">			when(rs.getString(&quot;uuid&quot;)).thenReturn(TEST_UUID);</span>
<span class="fc" id="L242">			when(rs.getString(&quot;username&quot;)).thenReturn(TEST_USERNAME);</span>
<span class="fc" id="L243">			when(rs.getString(&quot;content&quot;)).thenReturn(TEST_CONTENT);</span>
<span class="fc" id="L244">			when(rs.getString(&quot;time&quot;)).thenReturn(TEST_TIME);</span>
<span class="pc" id="L245">		} catch (SQLException sqlE) {</span>
<span class="nc" id="L246">			System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L247">			fail(&quot;Exception occurs when stubbing&quot;);</span>
		}
		// Test return value
<span class="fc" id="L250">		List&lt;Message&gt; resultList = messageDAO.queryMessage(1, TEST_MILLISEC);</span>
<span class="fc" id="L251">		assertEquals(1, resultList.size());</span>
<span class="fc" id="L252">		assertEquals(UUID.fromString(TEST_UUID), resultList.get(0).get_uuid());</span>
<span class="fc" id="L253">		assertEquals(TEST_USERNAME, resultList.get(0).get_username());</span>
<span class="fc" id="L254">		assertEquals(TEST_CONTENT, resultList.get(0).get_content());</span>
<span class="fc" id="L255">		assertEquals(TEST_TIME, dateFormatter.format(resultList.get(0).get_time()));</span>
		// Test function calls' order
<span class="fc" id="L257">		InOrder order = inOrder(connection, pstmt, rs);</span>
		try {
<span class="fc" id="L259">			order.verify(connection).prepareStatement(SELECT, Statement.RETURN_GENERATED_KEYS);</span>
<span class="fc" id="L260">			order.verify(pstmt).executeQuery();</span>
<span class="fc" id="L261">			order.verify(rs).next();</span>
<span class="fc" id="L262">			order.verify(rs, times(4)).getString(anyString());</span>
<span class="fc" id="L263">			order.verify(rs).next();</span>
<span class="fc" id="L264">			order.verify(pstmt).close();</span>
<span class="fc" id="L265">			order.verify(connection).close();</span>
<span class="fc" id="L266">			order.verifyNoMoreInteractions();</span>
<span class="pc" id="L267">		} catch (SQLException sqlE) {</span>
<span class="nc" id="L268">			System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L269">			fail(&quot;Exception occurs when testing function calls' order&quot;);</span>
		}
<span class="fc" id="L271">	}</span>

	@Test
	void testQueryMessageWithSize2AndMillisec1572364800000() {
<span class="fc" id="L275">		String SELECT = &quot;SELECT TOP 2 * FROM message WHERE time &lt;= ? ORDER BY time DESC&quot;;</span>
		// Stub
		try {
<span class="fc" id="L278">			when(connection.prepareStatement(SELECT, Statement.RETURN_GENERATED_KEYS)).thenReturn(pstmt);</span>
<span class="fc" id="L279">			when(pstmt.executeQuery()).thenReturn(rs);</span>
<span class="fc" id="L280">			when(rs.next()).thenReturn(true, true, false); // rs has 2 items</span>
<span class="fc" id="L281">			when(rs.getString(&quot;uuid&quot;)).thenReturn(TEST_UUID, TEST_UUID2);</span>
<span class="fc" id="L282">			when(rs.getString(&quot;username&quot;)).thenReturn(TEST_USERNAME, TEST_USERNAME2);</span>
<span class="fc" id="L283">			when(rs.getString(&quot;content&quot;)).thenReturn(TEST_CONTENT, TEST_CONTENT2);</span>
<span class="fc" id="L284">			when(rs.getString(&quot;time&quot;)).thenReturn(TEST_TIME, TEST_TIME2);</span>
<span class="pc" id="L285">		} catch (SQLException sqlE) {</span>
<span class="nc" id="L286">			System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L287">			fail(&quot;Exception occurs when stubbing&quot;);</span>
		}
		// Test return value
<span class="fc" id="L290">		List&lt;Message&gt; resultList = messageDAO.queryMessage(2, TEST_MILLISEC);</span>
<span class="fc" id="L291">		assertEquals(2, resultList.size());</span>
<span class="fc" id="L292">		assertEquals(UUID.fromString(TEST_UUID), resultList.get(0).get_uuid());</span>
<span class="fc" id="L293">		assertEquals(TEST_USERNAME, resultList.get(0).get_username());</span>
<span class="fc" id="L294">		assertEquals(TEST_CONTENT, resultList.get(0).get_content());</span>
<span class="fc" id="L295">		assertEquals(TEST_TIME, dateFormatter.format(resultList.get(0).get_time()));</span>
<span class="fc" id="L296">		assertEquals(UUID.fromString(TEST_UUID2), resultList.get(1).get_uuid());</span>
<span class="fc" id="L297">		assertEquals(TEST_USERNAME2, resultList.get(1).get_username());</span>
<span class="fc" id="L298">		assertEquals(TEST_CONTENT2, resultList.get(1).get_content());</span>
<span class="fc" id="L299">		assertEquals(TEST_TIME2, dateFormatter.format(resultList.get(1).get_time()));</span>
		// Test function calls' order
<span class="fc" id="L301">		InOrder order = inOrder(connection, pstmt, rs);</span>
		try {
<span class="fc" id="L303">			order.verify(connection).prepareStatement(SELECT, Statement.RETURN_GENERATED_KEYS);</span>
<span class="fc" id="L304">			order.verify(pstmt).executeQuery();</span>
<span class="fc" id="L305">			order.verify(rs).next();</span>
<span class="fc" id="L306">			order.verify(rs, times(4)).getString(anyString());</span>
<span class="fc" id="L307">			order.verify(rs).next();</span>
<span class="fc" id="L308">			order.verify(rs, times(4)).getString(anyString());</span>
<span class="fc" id="L309">			order.verify(rs).next();</span>
<span class="fc" id="L310">			order.verify(pstmt).close();</span>
<span class="fc" id="L311">			order.verify(connection).close();</span>
<span class="fc" id="L312">			order.verifyNoMoreInteractions();</span>
<span class="pc" id="L313">		} catch (SQLException sqlE) {</span>
<span class="nc" id="L314">			System.out.println(sqlE.getMessage());</span>
<span class="nc" id="L315">			fail(&quot;Exception occurs when testing function calls' order&quot;);</span>
		}
<span class="fc" id="L317">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span>lab02-timeline (1) (Nov 12, 2019 3:24:36 PM)</div></body></html>